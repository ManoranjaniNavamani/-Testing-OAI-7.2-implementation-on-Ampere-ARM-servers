#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include <string.h>
#include <armral.h> 

#define COMPRESSED_LENGTH 9
#define NUM_RBS 8
#define NUM_ELEMENTS (24 * NUM_RBS)
#define ORIGIN 2048
#define STEP 4
#define ABS_CENTER 4096
#define WIDTH 1024
#define RAND_INIT

int compress_bfp(int16_t *input, unsigned int num_elements, uint8_t *compressed, unsigned int *exponent) {
    uint32_t max_val = abs(input[0]);
    for (int i = 1; i < num_elements; i++) {
        if (abs(input[i]) > max_val) {
            max_val = abs(input[i]);
        }
    }
    
    *exponent = 32 + 1 - COMPRESSED_LENGTH;
    uint32_t mask = 0x80000000;
    while ((max_val & mask) == 0 && *exponent > 0) {
        *exponent -= 1;
        mask >>= 1;
    }

    memset(compressed, 0, (num_elements * COMPRESSED_LENGTH) / 8 + 1);
    for (int i = 0; i < num_elements; i++) {
        uint16_t scaled_value = (uint16_t)input[i] >> *exponent;
        uint32_t bit_offset = i * COMPRESSED_LENGTH;
        uint32_t byte_offset = bit_offset / 8;
        uint32_t bit_offset_in_byte = bit_offset % 8;

        uint16_t scaled_value_high = scaled_value >> (COMPRESSED_LENGTH - 8 + bit_offset_in_byte);
        scaled_value_high &= (((uint16_t)1 << (8 - bit_offset_in_byte)) - 1);
        uint16_t scaled_value_low = scaled_value << (16 - COMPRESSED_LENGTH - bit_offset_in_byte);
        scaled_value_low &= 0x000000ff;
        scaled_value_low &= (~(((uint16_t)1 << (16 - COMPRESSED_LENGTH - bit_offset_in_byte)) - 1));

        compressed[byte_offset] |= scaled_value_high;
        compressed[byte_offset + 1] |= scaled_value_low;
    }
    return num_elements;
}

int decompress_bfp(uint8_t *compressed, int num_elements, int16_t exponent, int16_t *decompressed) {
    for (int i = 0; i < num_elements; i++) {
        uint32_t bit_offset = i * COMPRESSED_LENGTH;
        uint32_t byte_offset = bit_offset / 8;
        uint32_t bit_offset_in_byte = bit_offset % 8;
        uint16_t scaled_value_high = compressed[byte_offset] & (((int16_t)1 << (8 - bit_offset_in_byte)) - 1);
        uint16_t scaled_value_low = compressed[byte_offset + 1] & (~(((int16_t)1 << (16 - COMPRESSED_LENGTH - bit_>
        uint16_t scaled_value = (scaled_value_low >> (16 - COMPRESSED_LENGTH - bit_offset_in_byte)) | (scaled_valu>
        
        uint16_t sign_bit_mask = 1 << (COMPRESSED_LENGTH - 1);
        uint16_t sign = scaled_value & sign_bit_mask;
        uint16_t sign_extend = sign ? 0xffffffff : 0x00000000;
         uint16_t sign_extend_mask = ~((1 << (COMPRESSED_LENGTH + exponent)) - 1);
        sign_extend &= sign_extend_mask;
        
        decompressed[i] = sign_extend | (int16_t)(scaled_value << exponent);
    }
    return num_elements;
}

int main() {
    int16_t input[NUM_ELEMENTS];
    uint8_t compressed[(NUM_ELEMENTS * COMPRESSED_LENGTH) / 8 + 1];
    memset(compressed, 0, sizeof(compressed));
    int16_t decompressed[NUM_ELEMENTS];
    unsigned int exponent[NUM_RBS];

    armral_compressed_data_9bit armral_compressed[NUM_RBS];
    int16_t armral_decompressed[NUM_ELEMENTS];

    // Initialize input data
    for (unsigned int i = 0; i < NUM_ELEMENTS; i++) {
#ifdef RAND_INIT
        int16_t tmp = ((rand() % (2 * WIDTH)) - WIDTH);
        input[i] = (tmp >= 0) ? (tmp + ABS_CENTER - WIDTH / 2) : (tmp - ABS_CENTER + WIDTH / 2);
#else
        input[i] = ORIGIN + STEP * i;
        input[i] = i % 2 ? input[i] : -input[i];
#endif
    }

    
    printf("Naive Compression:\n");
    for (int rb = 0; rb < NUM_RBS; rb++) {
        int compressed_size = compress_bfp(&input[24 * rb], 24, &compressed[2 * 24 * rb], &exponent[rb]);
        printf("RB#%d Compression successful. Exponent: %d. Compressed size: %d elements\n", rb, exponent[rb], com>
    }

    
    printf("ArmRAL Compression:\n");
    armral_block_float_compr_9bit(NUM_RBS, (armral_cmplx_int16_t *)input, armral_compressed, NULL);
    for (int rb = 0; rb < NUM_RBS; rb++) {
        printf("RB#%d Compression successful. Exponent: %d\n", rb, armral_compressed[rb].exp);
    }

    
    printf("Naive Decompression:\n");
    for (int rb = 0; rb < NUM_RBS; rb++) {
        decompress_bfp(&compressed[2 * 24 * rb], 24, exponent[rb], &decompressed[24 * rb]);
        printf("RB#%d Decompression successful. Decompressed size: 24 elements\n", rb);
    }

    
    printf("ArmRAL Decompression:\n");
    armral_block_float_decompr_9bit(NUM_RBS, armral_compressed, (armral_cmplx_int16_t *)armral_decompressed, NULL);

    
    printf("Verification of Compression-Decompression:\n");
    for (int i = 0; i < 100; i++) { // Print first 100 values for verification
        printf("Original: %04x, Decompressed: %04x, ArmRAL Decompressed: %04x\n", 
               input[i], decompressed[i], armral_decompressed[i]);
    }

    return 0;
}
